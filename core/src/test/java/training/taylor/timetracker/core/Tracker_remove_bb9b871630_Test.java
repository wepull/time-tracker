/*
Test generated by RoostGPT for test roost-test using AI Type Open AI and AI Model gpt-4

Test Scenario 1: Removal of Existing Time Entry
- Given a list of Time Entries with at least one entry
- When the remove function is called with an existing Time Entry as a parameter
- Then the specified Time Entry should be removed from the list

Test Scenario 2: Removal of Non-existing Time Entry
- Given a list of Time Entries
- When the remove function is called with a Time Entry that does not exist in the list as a parameter
- Then the list of Time Entries should remain unchanged

Test Scenario 3: Removal of Null Time Entry
- Given a list of Time Entries
- When the remove function is called with null as a parameter
- Then a NullPointerException should be thrown

Test Scenario 4: Removal of Time Entry from Empty List
- Given an empty list of Time Entries
- When the remove function is called with any Time Entry as a parameter
- Then an IndexOutOfBoundsException should be thrown

Test Scenario 5: Removal of Time Entry from List with Duplicate Entries
- Given a list of Time Entries with duplicate entries
- When the remove function is called with a Time Entry that has duplicates in the list
- Then only one instance of the specified Time Entry should be removed from the list

Test Scenario 6: Repeated Removal of Same Time Entry
- Given a list of Time Entries with at least one entry
- When the remove function is called repeatedly with the same Time Entry as a parameter
- Then the specified Time Entry should be removed in the first call, and subsequent calls should not affect the list

Please note that these scenarios assume the 'entries' list is a List<TimeEntry> instance and 'remove' is a method of the list.
*/
package training.taylor.timetracker.core;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import training.taylor.timetracker.core.dao.TimeEntry;

import java.util.ArrayList;
import java.util.List;

public class Tracker_remove_bb9b871630_Test {
    private Tracker tracker;
    private TimeEntry timeEntry1;
    private TimeEntry timeEntry2;

    @Before
    public void setup() {
        tracker = new Tracker();
        timeEntry1 = Mockito.mock(TimeEntry.class);
        timeEntry2 = Mockito.mock(TimeEntry.class);
    }

    @Test
    public void testRemoveExistingTimeEntry() {
        tracker.add(timeEntry1);
        tracker.remove(timeEntry1);
        Assert.assertEquals(0, tracker.size());
    }

    @Test
    public void testRemoveNonExistingTimeEntry() {
        tracker.add(timeEntry1);
        tracker.remove(timeEntry2);
        Assert.assertEquals(1, tracker.size());
    }

    @Test(expected = NullPointerException.class)
    public void testRemoveNullTimeEntry() {
        tracker.remove(null);
    }

    @Test(expected = IndexOutOfBoundsException.class)
    public void testRemoveTimeEntryFromEmptyList() {
        tracker.remove(timeEntry1);
    }

    @Test
    public void testRemoveTimeEntryFromListWithDuplicateEntries() {
        tracker.add(timeEntry1);
        tracker.add(timeEntry1);
        tracker.remove(timeEntry1);
        Assert.assertEquals(1, tracker.size());
    }

    @Test
    public void testRepeatedRemovalOfSameTimeEntry() {
        tracker.add(timeEntry1);
        tracker.remove(timeEntry1);
        tracker.remove(timeEntry1);
        Assert.assertEquals(0, tracker.size());
    }
}
