/*
Test generated by RoostGPT for test roost-test using AI Type Open AI and AI Model gpt-4

1. Scenario: TimeEntry object is present in the entries list
   - Given a TimeEntry object that is present in the entries list
   - When the remove method is called with this TimeEntry object
   - Then ensure the TimeEntry object is removed from the entries list

2. Scenario: TimeEntry object is not present in the entries list
   - Given a TimeEntry object that is not present in the entries list
   - When the remove method is called with this TimeEntry object
   - Then ensure no changes occur in the entries list and no exceptions are thrown

3. Scenario: Null is passed as parameter to the remove method
   - Given a null value
   - When the remove method is called with this null value
   - Then ensure that no changes occur in the entries list and no exceptions are thrown

4. Scenario: The entries list is empty
   - Given an empty entries list
   - When the remove method is called with any TimeEntry object
   - Then ensure no changes occur in the entries list and no exceptions are thrown

5. Scenario: Multiple identical TimeEntry objects are in the entries list
   - Given a entries list containing multiple identical TimeEntry objects
   - When the remove method is called with this TimeEntry object
   - Then ensure only one instance of the TimeEntry object is removed from the list

6. Scenario: TimeEntry object is present in the entries list more than once
   - Given a TimeEntry object that is present in the entries list more than once
   - When the remove method is called with this TimeEntry object
   - Then ensure all instances of the TimeEntry object are removed from the entries list

7. Scenario: Remove method is called consecutively
   - Given a TimeEntry object that is present in the entries list
   - When the remove method is called consecutively with this TimeEntry object
   - Then ensure the TimeEntry object is removed from the entries list after the first call and no changes or exceptions occur with subsequent calls.
*/
package training.taylor.timetracker.core;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import static org.mockito.Mockito.*;
import java.util.List;
import training.taylor.timetracker.core.dao.TimeEntry;

@RunWith(MockitoJUnitRunner.class)
public class Tracker_remove_bb9b871630_Test {
    @Mock
    private List<TimeEntry> entries;

    private Tracker tracker;

    @Mock
    private TimeEntry timeEntry;

    @Before
    public void setup() {
        tracker = new Tracker();
        tracker.setEntries(entries);  // Assuming Tracker has a setEntries method
    }

    @Test
    public void testRemoveTimeEntryPresentInList() {
        when(entries.contains(timeEntry)).thenReturn(true);
        tracker.remove(timeEntry);
        verify(entries, times(1)).remove(timeEntry);
    }

    @Test
    public void testRemoveTimeEntryNotPresentInList() {
        when(entries.contains(timeEntry)).thenReturn(false);
        tracker.remove(timeEntry);
        verify(entries, times(0)).remove(timeEntry);
    }

    @Test
    public void testRemoveNullTimeEntry() {
        tracker.remove(null);
        verify(entries, times(0)).remove(null);
    }

    @Test
    public void testRemoveFromEmptyList() {
        when(entries.isEmpty()).thenReturn(true);
        tracker.remove(timeEntry);
        verify(entries, times(0)).remove(timeEntry);
    }

    @Test
    public void testRemoveMultipleIdenticalTimeEntries() {
        when(entries.contains(timeEntry)).thenReturn(true).thenReturn(true).thenReturn(false);
        tracker.remove(timeEntry);
        verify(entries, times(1)).remove(timeEntry);
    }

    @Test
    public void testRemoveTimeEntryPresentMoreThanOnce() {
        when(entries.contains(timeEntry)).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(false);
        tracker.remove(timeEntry);
        verify(entries, times(1)).remove(timeEntry);
    }

    @Test
    public void testRemoveConsecutiveCalls() {
        when(entries.contains(timeEntry)).thenReturn(true).thenReturn(false);
        tracker.remove(timeEntry);
        verify(entries, times(1)).remove(timeEntry);
        tracker.remove(timeEntry);
        verify(entries, times(1)).remove(timeEntry);
    }
}
