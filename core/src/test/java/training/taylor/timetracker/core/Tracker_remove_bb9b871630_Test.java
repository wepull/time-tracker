/*
Test generated by RoostGPT for test roost-test using AI Type Open AI and AI Model gpt-4

1. Scenario: Test when the list "entries" is null
   - This scenario tests the behavior of the function when the list "entries" is not initialized. It should throw a NullPointerException.

2. Scenario: Test when the list "entries" is empty
   - This scenario tests the behavior of the function when the list "entries" is empty. The function should execute without any exceptions or errors, as removing an element from an empty list is a valid operation in Java.

3. Scenario: Test when the "entry" parameter is null
   - This scenario tests the behavior of the function when the "entry" parameter is null. The function should execute without any exceptions or errors, as removing a null element from a list is a valid operation in Java.

4. Scenario: Test when the "entry" parameter is not in the list "entries"
   - This scenario tests the behavior of the function when the "entry" parameter is not in the list "entries". The function should execute without any exceptions or errors, as removing an element that is not in the list is a valid operation in Java.

5. Scenario: Test when the "entry" parameter is in the list "entries"
   - This scenario tests the behavior of the function when the "entry" parameter is in the list "entries". The function should remove the "entry" parameter from the list "entries".

6. Scenario: Test when the "entry" parameter is in the list "entries" multiple times
   - This scenario tests the behavior of the function when the "entry" parameter is in the list "entries" multiple times. The function should remove all occurrences of the "entry" parameter from the list "entries".

7. Scenario: Test the function with a large list "entries"
   - This scenario tests the performance of the function when the list "entries" is large. The function should execute within a reasonable time and not cause any memory issues.

8. Scenario: Test the function with multiple concurrent calls
   - This scenario tests the behavior of the function when it is called concurrently from multiple threads. The function should execute correctly and not cause any concurrency issues.
*/
package training.taylor.timetracker.core;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import training.taylor.timetracker.core.dao.TimeEntry;
import java.util.ArrayList;
import java.util.List;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

public class Tracker_remove_bb9b871630_Test {
    private Tracker tracker;
    private TimeEntry entry;
    private List<TimeEntry> entries;

    @Before
    public void setup() {
        tracker = new Tracker();
        entry = Mockito.mock(TimeEntry.class);
        entries = new ArrayList<>();
        entries.add(entry);
    }

    @Test(expected = NullPointerException.class)
    public void testRemoveWhenEntriesIsNull() {
        tracker.remove(entry);
    }

    @Test
    public void testRemoveWhenEntriesIsEmpty() {
        tracker.remove(entry);
        assertEquals(0, tracker.size());
    }

    @Test
    public void testRemoveWhenEntryIsNull() {
        tracker.add(null);
        tracker.remove(null);
        assertEquals(0, tracker.size());
    }

    @Test
    public void testRemoveWhenEntryIsNotInEntries() {
        TimeEntry anotherEntry = Mockito.mock(TimeEntry.class);
        tracker.add(entry);
        tracker.remove(anotherEntry);
        assertEquals(1, tracker.size());
    }

    @Test
    public void testRemoveWhenEntryIsInEntries() {
        tracker.add(entry);
        tracker.remove(entry);
        assertEquals(0, tracker.size());
    }

    @Test
    public void testRemoveWhenEntryIsInEntriesMultipleTimes() {
        tracker.add(entry);
        tracker.add(entry);
        tracker.remove(entry);
        assertEquals(0, tracker.size());
    }

    @Test(timeout = 1000)
    public void testRemoveWithLargeEntries() {
        for (int i = 0; i < 10000; i++) {
            tracker.add(entry);
        }
        for (int i = 0; i < 10000; i++) {
            tracker.remove(entry);
        }
        assertEquals(0, tracker.size());
    }

    @Test
    public void testRemoveWithMultipleConcurrentCalls() throws InterruptedException {
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                tracker.add(entry);
                tracker.remove(entry);
            }
        });

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                tracker.add(entry);
                tracker.remove(entry);
            }
        });

        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();

        assertEquals(0, tracker.size());
    }
}
