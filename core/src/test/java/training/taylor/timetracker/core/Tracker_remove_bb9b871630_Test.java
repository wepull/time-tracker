/*
Test generated by RoostGPT for test roost-test using AI Type Open AI and AI Model gpt-4

Test Scenario 1: 
Test the remove method with a valid entry that exists in the list. The test should verify that the entry is removed successfully.

Test Scenario 2:  
Test the remove method with a valid entry that does not exist in the list. The test should verify that the method does not throw an exception and the list remains the same.

Test Scenario 3:  
Test the remove method with a null entry. The test should verify that the method handles null values correctly and does not throw a NullPointerException.

Test Scenario 4:  
Test the remove method when the entries list is empty. The test should verify that the method does not throw an exception when trying to remove an entry from an empty list.

Test Scenario 5: 
Test the remove method with multiple entries in the list. Remove one of the entries and verify that only the specified entry is removed and the remaining entries are still present in the list.

Test Scenario 6:  
Test the remove method with an entry that exists multiple times in the list. The test should verify that all occurrences of the entry are removed from the list.

Test Scenario 7: 
Test the remove method when the entries list is null. The test should verify that the method handles this situation correctly and does not throw a NullPointerException.

Test Scenario 8:  
Test the remove method with a list that contains null entries. The test should verify that the method handles this situation correctly and does not throw a NullPointerException. 

Test Scenario 9: 
Test the remove method by concurrently removing entries from the list in a multi-threading environment. The test should verify that the method is thread-safe and does not result in a ConcurrentModificationException. 

Test Scenario 10: 
Test the remove method with a list that contains duplicate entries. The test should verify that all duplicates are removed when the method is called.
*/
package training.taylor.timetracker.core;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import training.taylor.timetracker.core.dao.TimeEntry;

import java.util.ArrayList;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class Tracker_remove_bb9b871630_Test {
    @Mock
    private List<TimeEntry> entries;

    private Tracker tracker;

    @Before
    public void setup() {
        MockitoAnnotations.initMocks(this);
        tracker = new Tracker();
        tracker.setEntries(entries);
    }

    @Test
    public void testRemoveExistingEntry() {
        TimeEntry entry = new TimeEntry();
        when(entries.remove(entry)).thenReturn(true);
        tracker.remove(entry);
        verify(entries).remove(entry);
    }

    @Test
    public void testRemoveNonExistingEntry() {
        TimeEntry entry = new TimeEntry();
        when(entries.remove(entry)).thenReturn(false);
        tracker.remove(entry);
        verify(entries).remove(entry);
    }

    @Test
    public void testRemoveNullEntry() {
        when(entries.remove(null)).thenReturn(false);
        tracker.remove(null);
        verify(entries).remove(null);
    }

    @Test
    public void testRemoveFromEmptyList() {
        when(entries.isEmpty()).thenReturn(true);
        TimeEntry entry = new TimeEntry();
        tracker.remove(entry);
        verify(entries).remove(entry);
    }

    @Test
    public void testRemoveOneOfMultipleEntries() {
        TimeEntry entry1 = new TimeEntry();
        TimeEntry entry2 = new TimeEntry();
        when(entries.remove(entry1)).thenReturn(true);
        tracker.remove(entry1);
        verify(entries).remove(entry1);
        assertFalse(entries.contains(entry1));
        assertEquals(1, entries.size());
    }

    @Test
    public void testRemoveAllOccurrencesOfEntry() {
        TimeEntry entry = new TimeEntry();
        when(entries.remove(entry)).thenReturn(true, false);
        tracker.remove(entry);
        verify(entries).remove(entry);
        assertFalse(entries.contains(entry));
    }

    @Test(expected = NullPointerException.class)
    public void testRemoveFromNullList() {
        entries = null;
        tracker.setEntries(entries);
        tracker.remove(new TimeEntry());
    }

    @Test
    public void testRemoveNullEntryFromList() {
        entries = new ArrayList<>();
        entries.add(null);
        tracker.setEntries(entries);
        tracker.remove(null);
        assertFalse(entries.contains(null));
    }

    @Test
    public void testRemoveEntryConcurrently() {
        // TODO: Add code for testing concurrent removal of entries
    }

    @Test
    public void testRemoveDuplicateEntries() {
        TimeEntry entry = new TimeEntry();
        entries = new ArrayList<>();
        entries.add(entry);
        entries.add(entry);
        tracker.setEntries(entries);
        tracker.remove(entry);
        assertFalse(entries.contains(entry));
    }
}
