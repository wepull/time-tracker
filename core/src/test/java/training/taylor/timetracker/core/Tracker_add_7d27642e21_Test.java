/*
Test generated by RoostGPT for test roost-test using AI Type Open AI and AI Model gpt-4

1. **Scenario:** Validate the addition of a new `TimeEntry` object to the `entries` list.
   **Test Case:** Create a new `TimeEntry` object and pass it to the `add()` method. Then confirm that the `entries` list contains the new `TimeEntry` object.

2. **Scenario:** Validate the behavior when a `null` value is passed to the `add()` method.
   **Test Case:** Pass a `null` value to the `add()` method and confirm that an appropriate exception is thrown, or the `entries` list remains unchanged.

3. **Scenario:** Validate the addition of duplicate `TimeEntry` objects.
   **Test Case:** Create a `TimeEntry` object and pass it to the `add()` method twice. Confirm whether duplicates are allowed in the `entries` list.

4. **Scenario:** Validate the order of `TimeEntry` objects in the `entries` list.
   **Test Case:** Add multiple `TimeEntry` objects to the `entries` list and confirm that they are stored in the order they were added.

5. **Scenario:** Validate the addition of a `TimeEntry` object when the `entries` list is at its maximum capacity.
   **Test Case:** Fill the `entries` list to its maximum capacity and then try to add another `TimeEntry` object. Confirm whether the list expands to accommodate the new object or if an error is thrown.

6. **Scenario:** Validate the behavior of the `add()` method when it is called concurrently.
   **Test Case:** Use multiple threads to call the `add()` method at the same time and confirm whether the `entries` list correctly stores all the `TimeEntry` objects.

7. **Scenario:** Validate the behavior when a `TimeEntry` object with invalid data is added.
   **Test Case:** Create a `TimeEntry` object with invalid data and pass it to the `add()` method. Confirm whether the object is rejected or added to the list.

8. **Scenario:** Validate the memory management when a large number of `TimeEntry` objects are added.
   **Test Case:** Add a large number of `TimeEntry` objects to the `entries` list and confirm whether the program handles the memory efficiently.

9. **Scenario:** Validate the behavior when the `add()` method is called without an initialized `entries` list.
   **Test Case:** Call the `add()` method without initializing the `entries` list and confirm that an appropriate error is thrown.

10. **Scenario:** Validate the behavior of the `add()` method after a `TimeEntry` object has been removed from the `entries` list.
    **Test Case:** Remove a `TimeEntry` object from the `entries` list and then call the `add()` method. Confirm that the `entries` list correctly stores the new `TimeEntry` object.
*/
package training.taylor.timetracker.core;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import training.taylor.timetracker.core.dao.TimeEntry;

import java.util.ArrayList;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.*;

public class Tracker_add_7d27642e21_Test {

    private Tracker tracker;
    private List<TimeEntry> entries;

    @Before
    public void setup() {
        tracker = new Tracker();
        entries = new ArrayList<>();
        tracker.entries = entries;
    }

    @Test
    public void testAddTimeEntry() {
        TimeEntry entry = Mockito.mock(TimeEntry.class);
        tracker.add(entry);
        assertEquals(1, tracker.size());
        assertEquals(entry, tracker.get(0));
    }

    @Test(expected = NullPointerException.class)
    public void testAddNullTimeEntry() {
        tracker.add(null);
    }

    @Test
    public void testAddDuplicateTimeEntry() {
        TimeEntry entry = Mockito.mock(TimeEntry.class);
        tracker.add(entry);
        tracker.add(entry);
        assertEquals(2, tracker.size());
    }

    @Test
    public void testAddTimeEntryOrder() {
        TimeEntry entry1 = Mockito.mock(TimeEntry.class);
        TimeEntry entry2 = Mockito.mock(TimeEntry.class);
        tracker.add(entry1);
        tracker.add(entry2);
        assertEquals(entry1, tracker.get(0));
        assertEquals(entry2, tracker.get(1));
    }

    @Test
    public void testAddTimeEntryBeyondCapacity() {
        for (int i = 0; i < 10000; i++) {
            tracker.add(Mockito.mock(TimeEntry.class));
        }
        assertTrue(tracker.size() > 9999);
    }

    @Test
    public void testAddTimeEntryConcurrently() throws InterruptedException {
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                tracker.add(Mockito.mock(TimeEntry.class));
            }
        });

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                tracker.add(Mockito.mock(TimeEntry.class));
            }
        });

        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();

        assertEquals(10000, tracker.size());
    }

    @Test(expected = NullPointerException.class)
    public void testAddInvalidTimeEntry() {
        TimeEntry entry = Mockito.mock(TimeEntry.class);
        when(entry.getHours()).thenReturn(-1);
        tracker.add(entry);
    }

    @Test
    public void testAddLargeNumberOfTimeEntries() {
        for (int i = 0; i < 1000000; i++) {
            tracker.add(Mockito.mock(TimeEntry.class));
        }
        assertEquals(1000000, tracker.size());
    }

    @Test(expected = NullPointerException.class)
    public void testAddWithoutInitializingList() {
        Tracker trackerWithoutList = new Tracker();
        trackerWithoutList.add(Mockito.mock(TimeEntry.class));
    }

    @Test
    public void testAddAfterRemovingTimeEntry() {
        TimeEntry entry1 = Mockito.mock(TimeEntry.class);
        TimeEntry entry2 = Mockito.mock(TimeEntry.class);
        tracker.add(entry1);
        tracker.remove(entry1);
        tracker.add(entry2);
        assertEquals(1, tracker.size());
        assertEquals(entry2, tracker.get(0));
    }
}
