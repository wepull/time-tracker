/*
Test generated by RoostGPT for test roost-test using AI Type Open AI and AI Model gpt-4

1. **Scenario:** Validate the addition of a new `TimeEntry` object to the `entries` list.
   **Test Case:** Create a new `TimeEntry` object and pass it to the `add()` method. Then confirm that the `entries` list contains the new `TimeEntry` object.

2. **Scenario:** Validate the behavior when a `null` value is passed to the `add()` method.
   **Test Case:** Pass a `null` value to the `add()` method and confirm that an appropriate exception is thrown, or that the `entries` list remains unchanged.

3. **Scenario:** Validate the behavior when an existing `TimeEntry` object is added to the `entries` list.
   **Test Case:** Add an existing `TimeEntry` object to the `entries` list and confirm that the `entries` list contains duplicates, or that the duplicate is not added, depending on the desired behavior.

4. **Scenario:** Validate the behavior when the `entries` list is full.
   **Test Case:** If the `entries` list has a maximum size, fill the `entries` list to its maximum capacity and then pass a new `TimeEntry` object to the `add()` method. Confirm that an appropriate exception is thrown or that the oldest `TimeEntry` object is removed from the `entries` list.

5. **Scenario:** Validate the behavior when the `add()` method is called concurrently.
   **Test Case:** If the `entries` list is used in a multi-threaded context, call the `add()` method concurrently from multiple threads and confirm that all `TimeEntry` objects are added correctly and that no data corruption occurs.

6. **Scenario:** Validate the behavior when adding a `TimeEntry` object with invalid data.
   **Test Case:** Create a new `TimeEntry` object with invalid data and pass it to the `add()` method. Confirm that an appropriate exception is thrown or that the `TimeEntry` object is not added to the `entries` list.

7. **Scenario:** Validate the order of `TimeEntry` objects in the `entries` list after calling the `add()` method multiple times.
   **Test Case:** Add multiple `TimeEntry` objects to the `entries` list and confirm that the `TimeEntry` objects are in the correct order.
*/
package training.taylor.timetracker.core;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import static org.mockito.Mockito.*;

import java.util.ArrayList;
import java.util.List;

import static org.junit.Assert.*;

public class Tracker_add_7d27642e21_Test {

    @Mock
    private List<TimeEntry> entries;

    @InjectMocks
    private Tracker tracker;

    @Before
    public void setup() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testAddTimeEntry() {
        TimeEntry entry = new TimeEntry();
        tracker.add(entry);
        verify(entries, times(1)).add(entry);
    }

    @Test(expected = NullPointerException.class)
    public void testAddNullTimeEntry() {
        tracker.add(null);
    }

    @Test
    public void testAddExistingTimeEntry() {
        TimeEntry entry = new TimeEntry();
        tracker.add(entry);
        tracker.add(entry);
        verify(entries, times(2)).add(entry);
    }

    @Test(expected = IndexOutOfBoundsException.class)
    public void testAddTimeEntryWhenListIsFull() {
        when(entries.size()).thenReturn(Integer.MAX_VALUE);
        TimeEntry entry = new TimeEntry();
        tracker.add(entry);
    }

    @Test
    public void testAddTimeEntryConcurrently() throws InterruptedException {
        int threadCount = 1000;
        TimeEntry entry = new TimeEntry();
        for (int i = 0; i < threadCount; i++) {
            new Thread(() -> tracker.add(entry)).start();
        }
        Thread.sleep(1000); // wait for all threads to finish
        verify(entries, times(threadCount)).add(entry);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testAddInvalidTimeEntry() {
        TimeEntry entry = new TimeEntry();
        entry.setHours(-1);  // Invalid data
        tracker.add(entry);
    }

    @Test
    public void testOrderOfTimeEntries() {
        TimeEntry entry1 = new TimeEntry();
        TimeEntry entry2 = new TimeEntry();
        TimeEntry entry3 = new TimeEntry();

        tracker.add(entry1);
        tracker.add(entry2);
        tracker.add(entry3);

        List<TimeEntry> expectedOrder = new ArrayList<>();
        expectedOrder.add(entry1);
        expectedOrder.add(entry2);
        expectedOrder.add(entry3);

        assertEquals(expectedOrder, entries);
    }
}
